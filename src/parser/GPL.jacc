/**
*   This is the frontend implementation of the GPL interpreter
*   @author Yufei Liu and Jacob Jensen
*/

%{
  import java.util.*;
  import java.io.*;
  
  import interpreter.types.NumberType;
  import interpreter.types.*;
  import helper.*;

  class SemanticWrapper {
    public Object val;
    public SemanticWrapper(Object val) {
        this.val = val;
    }
  }

  class GPLHelper {
      public static boolean isTrue(Object obj) {
      
        if (obj == null) return false;
      
        if (((Double)(obj)).doubleValue()!=0)
            return true;
        else
            return false;
      }
  }
  
  class GPLLexer implements GPLTokens {
	private int lastChar = 32;
    private int token;
    private SemanticWrapper yylval;
    private Stack<Boolean> toSkip = new Stack<Boolean>();
    private Stack<Boolean> ifEvaluatedToTrue = new Stack<Boolean>();
    private Stack<Integer> skipCounter = new Stack<Integer>();
    
    public Object lastReturn;
    
    //This tells the lexer to start recording the character stream (used for backtracking)
    private boolean record = false;
    private int recordCap = 0;
    private int recordLow = 0;
    private Stack<String> whileBodies = new Stack<String>();
    private Stack<String> whileConditions = new Stack<String>();
    
    private boolean inLiteral = false;
    private boolean inComment = false;
    private boolean waitingForReturn = false;
    private Stack<Integer> blockTypes = new Stack<Integer>();
    
    private String s;
    private Stack<HashMap<String, Object>> scopes = new Stack<HashMap<String, Object>>();
    
    private Stack<Reader> inputs = new Stack<Reader>();
  
    public GPLLexer() throws IOException{
        scopes.push(new HashMap<String, Object>());
        inputs.push(new InputStreamReader(System.in));
    }
    
    public void addInput(Reader reader) {
        inputs.push(reader);
    }
    
    public void setScopes(Stack<HashMap<String, Object>> scopes) {
        this.scopes = scopes;
    }
    
    public Stack<HashMap<String, Object>> getScopes() {
        return scopes;
    }
  
    /** Read a single input character from standard input.
     */
    private int nextChar() {
        try {
            int c = inputs.peek().read();
            if (record) {
                for (int i = recordLow; i < recordCap; i++) {
                    whileBodies.set(i, whileBodies.get(i) + (char)c);
                }
            }
            //System.out.println((toSkip.size()==0 || !toSkip.peek() ? "" : " -- ") + ((char)c=='\n' ? "NL" : (char)c) + " : " + c);
            
            return c;
        } catch (Exception e) {
            return -1;
        }
    }
    
    private String getLine() {
        try {
            String out = "";
            int c = inputs.peek().read();
            while (c!='\n' && c!='\r') {
                if (record) {
                    for (int i = recordLow; i < recordCap; i++) {
                        whileBodies.set(i, whileBodies.get(i) + (char)c);
                    }
                }
                out+=(char)c;
                c = inputs.peek().read();
            }
            
            if (record) {
                    for (int i = recordLow; i < recordCap; i++) {
                        whileBodies.set(i, whileBodies.get(i) + "\n");
                    }
                }
            
            return out;
        } catch (Exception e) {
          return "";
        }
    }
    
    /** Read the next token and return the
     *  corresponding integer code.
     */
    public int nextToken() {
    
	    int c = lastChar;
        s="";
        
        if (inComment) {
            while (c!='\n') {
                c = nextChar();
            }
            inComment = false;
            lastChar = '\n';
            return nextToken();
        }
        
        if (inLiteral) {
            while (c!='"') {
                s += Character.toString((char)c);
                c = nextChar();
            }
            inLiteral = false;
            if (toSkip.size()==0 || !toSkip.peek()) {
                yylval = new SemanticWrapper(new StringType(s.substring(1,s.length())));
                return token=STRING_LITERAL;
            } else {
                return nextToken();
            }
        }
        
		while (c==32 || c==11 || c==13 || c=='\t') {
			c=nextChar();
		}
		if (c<0) {
            return (token=ENDINPUT);
        }
        if (c == '\n') {
            if (toSkip.size()==0 || !toSkip.peek()) {
                return token=NL;
            } else {
                return nextToken();
            }
        }
        
        
        lastChar=32;
        
		//Take care of all the special one-character tokens
		switch (c) {
          case '+' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token='+';
                    } else {
                        return nextToken();
                    }
                }
          case '-' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token='-';
                    } else {
                        return nextToken();
                    }
                }
          case '*' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token='*';
                    } else {
                        return nextToken();
                    }
                }
          case '/' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token='/';
                    } else {
                        return nextToken();
                    }
                }
          case '%' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token='%';
                    } else {
                        return nextToken();
                    }
                }
          case '^' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token='^';
                    } else {
                        return nextToken();
                    }
                }
		  case '(' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token='(';
                    } else {
                        return nextToken();
                    }
                }
          case ')' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token=')';
                    } else {
                        return nextToken();
                    }
                }
           case '[' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token='[';
                    } else {
                        return nextToken();
                    }
                }
          case ']' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token=']';
                    } else {
                        return nextToken();
                    }
                }
		  case '=' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token='=';
                    } else {
                        return nextToken();
                    }
                }
          case '>' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token=GT;
                    } else {
                        return nextToken();
                    }
                }
          case '~' :
                {
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token=EQ;
                    } else {
                        return nextToken();
                    }
                }
          case '`' :
                {
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token=NE;
                    } else {
                        return nextToken();
                    }
                }
		  case '<' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token=LT;
                    } else {
                        return nextToken();
                    }
                }
          case '@' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token=GE;
                    } else {
                        return nextToken();
                    }
                }
          case '$' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token=LE;
                    } else {
                        return nextToken();
                    }
                }
          case ',' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token=',';
                    } else {
                        return nextToken();
                    }
                }
		  case '.' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token='.';
                    } else {
                        return nextToken();
                    }
                }
		  case '!' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token='!';
                    } else {
                        return nextToken();
                    }
                }
		  case '&' : 
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token='&';
                    } else {
                        return nextToken();
                    }
                }
          case '|' :
                { 
                    if (toSkip.size()==0 || !toSkip.peek()) {
                        return token='|';
                    } else {
                        return nextToken();
                    }
                }
          case '"' :
                     {inLiteral = true; return nextToken();}
          case '#' :
                     {inComment = true; return nextToken();}
		}
        
        
		while ((c>=65 && c<=90) || (c>=97 && c<=122) || (c>=48 && c<=57) || (c==34) || (s.matches("[0-9]+") && c=='.')) {
			if (c<0) break;
			s+=Character.toString((char)c);
			c=nextChar();
		}
        
        lastChar = c;
            if (s.matches("([+-]?[0-9]*\\.[0-9]+)|([+-]?[0-9]+)")) {
                if (toSkip.size()==0 || !toSkip.peek()) {
                    yylval = new SemanticWrapper(new NumberType(Double.parseDouble(s)));
                    
                    return token=NUMBER;
                } else {
                    return nextToken();
                }
            } else if (s.equals("Number")||s.equals("Graph")||s.equals("String")||s.equals("Function")) {
                if (toSkip.size()==0 || !toSkip.peek()) {
                    yylval = new SemanticWrapper(new StringType(s));
                    return token=TYPE;
                } else {
                    return nextToken();
                }
            } else if (s.equals("print")) {
                
                if (toSkip.size()==0 || !toSkip.peek()) {
                    return token=PRINT;
                } else {
                    return nextToken();
                }
            } else if (s.equals("include")) {
                if (toSkip.size()==0 || !toSkip.peek()) {
                
                    String line = getLine();
                    
                    eval(line, true, false);
                    String randomFile = (int)(Math.random()*1000) + ".tmp";
                    Preprocessor preprocessor2 = null;
                    BufferedReader reader = null;
                    
                    try {
                        preprocessor2 = new Preprocessor(((Type)(lastReturn)).getValue(), randomFile);
                        reader = new BufferedReader(new FileReader(randomFile));
                    } catch (Exception e) {
                        System.out.println("Bad file name '" + ((Type)(lastReturn)).getValue() + "', include failed.");
                        System.exit(1);
                    }
                    
                    if (preprocessor2==null) return nextToken();
                    loadFunctions(preprocessor2);
                    if (reader!=null) {
                        String code = "";
                        String s;
                        try {
                            while((s = reader.readLine()) != null){
                                code = code + s + (char)13 + "\n";
                            }
                            
                            File aFile = new File(randomFile);
                            aFile.delete();
                        } catch (Exception e) {}
                        
                        eval(code, true, false);
                    }
                    
                    return nextToken();
                } else {
                    return nextToken();
                }
            } else if (s.equals("if")) {
            
                //System.out.println("reached if at depth " + (toSkip.size()+1));
                
                if (toSkip.size()>0 && toSkip.peek()) {
                    //System.out.println("this if is to be ignored due to inheritance!");
                    skipCounter.set(skipCounter.size()-1, skipCounter.peek()+1);
                    //System.out.println("- if pushed toSkip!");
                    ifEvaluatedToTrue.push(false);
                    toSkip.push(true);
                    blockTypes.push(0);
                    skipCounter.push(0);
                    return nextToken();
                }
                
                if (toSkip.size()==0 || !toSkip.peek()) {
                    //System.out.println("this if is not to be ignored!");
                    blockTypes.push(0);
                    boolean decision = eval(getLine());
                    //System.out.println("if evaluated to: " + decision);
                    //System.out.println("- if pushed toSkip!");
                    if (decision) {
                        toSkip.push(false);
                        ifEvaluatedToTrue.push(true);
                        skipCounter.push(0);
                        scopes.push(new HashMap<String, Object>());
                        return nextToken();
                    } else {
                        //System.out.println("About to skip!");
                        ifEvaluatedToTrue.push(false);
                        toSkip.push(true);
                        skipCounter.push(0);
                        return nextToken();
                    }
                } else {
                    //System.out.println("this if is to be ignored!");
                    skipCounter.set(skipCounter.size()-1, skipCounter.peek()+1);
                    System.out.println("- if pushed toSkip!");
                    ifEvaluatedToTrue.push(false);
                    toSkip.push(true);
                    blockTypes.push(0);
                    skipCounter.push(0);
                    return nextToken();
                }
                
            } else if (s.equals("elsif")) {
            
                //System.out.println("reached elsif at depth " + toSkip.size());
                //System.out.println("   toSkip: " + toSkip.peek());
                //System.out.println("   skipCounter: " + skipCounter.peek());
                //System.out.println("   ifEvaluatedToTrue: " + ifEvaluatedToTrue.peek());
                
                if (toSkip.size()>1 && toSkip.get(toSkip.size()-2)) {
                    //System.out.println("this elsif is to be ignored due to inheritance!");
                    return nextToken();
                }
                
                if (!toSkip.peek()) {
                    //System.out.println("this elsif is not to be ignored!");
                    //System.out.println("if evaluated to true, ignore elsif!");
                    toSkip.set(toSkip.size()-1, true);
                    scopes.pop();
                    return nextToken();
                    
                } else {
                    //System.out.println("this elsif is to be ignored!");
                    if (skipCounter.peek()>0) {
                        return nextToken();
                    }
                    String restOfLine = getLine();
                    
                    //System.out.println("Line to be evaluated:" + restOfLine);
                    toSkip.set(toSkip.size()-1, false);
                    nextToken();
                    lastChar=10;
                    
                    boolean decision = eval(restOfLine);
                    
                    //System.out.println("elsif decision: "+ decision);
                    if (decision) {
                        
                        scopes.push(new HashMap<String, Object>());
                        return nextToken();
                    } else {
                        toSkip.set(toSkip.size()-1, true);
                        skipCounter.set(skipCounter.size()-1, 0);
                        return nextToken();
                    }
                }
            } else if (s.equals("else")) {
                //System.out.println("else reached at depth " + toSkip.size());
                //System.out.println("   toSkip: " + toSkip.peek());
                //System.out.println("   skipCounter: " + skipCounter.peek());
                //System.out.println("   ifEvaluatedToTrue: " + ifEvaluatedToTrue.peek());
                
                if (toSkip.size()>1 && toSkip.get(toSkip.size()-2)) {
                    System.out.println("this else is to be ignored due to inheritance!");
                    return nextToken();
                }
                
                if (!toSkip.peek()) {
                    //System.out.println("this else is not to be ignored!");
                    scopes.pop();
                    toSkip.set(toSkip.size()-1, true);
                    skipCounter.set(skipCounter.size()-1, 0);
                    return nextToken();
                } else if (toSkip.peek() && ifEvaluatedToTrue.peek()) {
                    //System.out.println("this else is to be ignored since if evaluated to true!");
                    toSkip.set(toSkip.size()-1, true);
                    skipCounter.set(skipCounter.size()-1, 0);
                    return nextToken();
                } else{
                    //System.out.println("this else is to be ignored!");
                
                    if (skipCounter.peek()>0) {
                        return nextToken();
                    }
                    
                    toSkip.set(toSkip.size()-1, false);
                    scopes.push(new HashMap<String, Object>());
                    return nextToken();
                }
            } else if (s.equals("while")) {
            
                if (toSkip.size()==0 || !toSkip.peek()) {
                    blockTypes.push(1);
                    String cond = getLine();
                    boolean decision = eval(cond);
                    
                    if (decision) {
                    
                        if (!record) record = true;
                        whileBodies.push("");
                        whileConditions.push(cond);
                        
                        scopes.push(new HashMap<String, Object>());
                        recordCap++;
                        
                        return nextToken();
                    } else {
                        
                        scopes.push(new HashMap<String, Object>());
                        return nextToken();
                    }
                } else {
                    skipCounter.set(skipCounter.size()-1, skipCounter.peek()+1);
                    return nextToken();
                }
            } else if (s.equals("next")) {
                if (toSkip.size()==0 || !toSkip.peek()) {
                    scopes.pop();
                    return token=NEXT;
                } else {
                    return nextToken();
                }
            } else if (s.equals("last")) {
                if (!toSkip.peek()) {
                    scopes.pop();
                    return token=LAST;
                } else {
                    return nextToken();
                }
                
            } else if (s.equals("end")) {
            
                //Not to be skipped
                if (toSkip.size()==0 || !toSkip.peek()) {
                
                    //This is the end tag for a while loop
                    if (blockTypes.peek()==1) {
                    
                        //Strip the "end" line from the while body
                        
                        String whileBody = whileBodies.peek().substring(0,whileBodies.peek().length()-4);
                        
                        String cond = whileConditions.peek();
                        
                        int lastRecordLow = recordLow;
                        int lastRecordCap = recordCap;
                        
                        //System.out.println("First noticed end..." + recordLow + "," + recordCap);
                        
                        while (eval(cond)) {
                            recordLow = whileBodies.size();
                            recordCap = whileBodies.size();
                            
                            //System.out.println("During while..." + recordLow + "," + recordCap);
                            scopes.pop();
                            scopes.push(new HashMap<String, Object>());
                            eval(whileBody,false);
                        }
                        recordLow=lastRecordLow;
                        recordCap=lastRecordCap - 1;
                        
                        //System.out.println("After end..." + recordLow + "," + recordCap);
                        
                        whileBodies.pop();
                        whileConditions.pop();
                        if (whileBodies.size()==0) record = false;
                    } else {
                        //System.out.println("- end popped toSkip 1!");
                        blockTypes.pop();
                        toSkip.pop();
                        ifEvaluatedToTrue.pop();
                        skipCounter.pop();
                        scopes.pop();
                    }
                    return nextToken();
                } else {
                        if (skipCounter.size()>1 && skipCounter.get(skipCounter.size()-2)>0) {
                            skipCounter.set(skipCounter.size()-2, skipCounter.get(skipCounter.size()-2)-1);
                        }
                        
                        //System.out.println("- end popped toSkip 2!");
                        blockTypes.pop();
                        toSkip.pop();
                        ifEvaluatedToTrue.pop();
                        skipCounter.pop();
                        return nextToken();
                }
            } else if (s.equals("exit")) {
                return token=EXIT;
            } else if (s.equals("return")) {
                if (toSkip.size()==0 || !toSkip.peek()) {
                    eval(getLine());
                    
                    //This forces the current input stream to end
                    lastChar = -1;
                    return token=RETURN;
                } else {
                    return nextToken();
                }
            } else if (s.matches("[a-zA-Z_][a-zA-Z0-9_]*")) {
                yylval = new SemanticWrapper(new StringType(s));
                return token=ID;
            }
            
		return -1;
    }
    
    /** Return the token code for the current lexeme.
     */
    public int getToken() {
        //System.out.println("getToken called, to return: " + token);
        if (token==0) return nextToken();
        return token;
    }
	
    private boolean eval(String code) {
        return eval(code, true, true);
    }
    
    private boolean eval(String code, boolean interactive) {
        return eval(code, interactive, true);
    }
    
    /**
        Does not handle scopes, caller takes care of it!
    */
    private boolean eval(String code, boolean interactive, boolean strip) {
        
        lastChar = 32;
        
        lastReturn = null;
        
        //Strip off all extra new lines
        if (strip) {
            while (code.charAt(0)=='\n' || code.charAt(0)==13) {
                code = code.substring(1,code.length());
            }
        }
        
        inputs.push(new StringReader(code));
        
        /*
        System.out.println("---------------- Eval: --------------");
        System.out.println(code);
        System.out.println("-----------Scope content ------------");
        for (HashMap<String,Object> h : scopes) {
            System.out.println(h);
        }
        System.out.println("-------- Input stack size ----------");
        System.out.println(inputs.size());
        System.out.println("------------------------------------");
        */
        
        boolean savedRecord = false;
        if (interactive) {
            savedRecord = record;
            record = false;
        }
        
        GPLParser liner = new GPLParser(this);
        liner.setScopes(scopes);
        liner.setInteractive(interactive);
        liner.parse();
        inputs.pop();
        
        lastChar = 32;
        
        if (interactive) {
            record = savedRecord;
        }
        
        
        if (liner.getReturn()==null) return false;
        
        lastReturn = liner.getReturn().val;
        
        boolean theReturn = false;
        
        try {
            theReturn = GPLHelper.isTrue(((NumberType)(liner.getReturn().val)).getDouble());
        } catch (Exception e) {}
        return theReturn;
    }
    
    public Object evalFunction(String code, ArrayList<String> formalArgs, ArrayList<Object> actualArgs) {
        scopes.push(new HashMap<String, Object>());
        
        int i = 0;
        for (String a : formalArgs) {
            scopes.peek().put(a, actualArgs.get(i));
            i++;
        }
        eval(code);
        scopes.pop();
        return lastReturn;
    }
    
    public void loadFunctions(Preprocessor p) {
        for (FunctionDef ff : p.functions) {
            Function f = new Function(ff.name, ff.code, ff.paramsType);
            f.args = ff.args;
            scopes.get(0).put(f.name, f);
        }
    }
    
	SemanticWrapper getSemantic() {
		return yylval;
	}
  }

  class Main {
    public static void main(String[] args) throws Exception {
      if (args.length==0) {
          System.out.println("Welcome to GPL, enter commands to run:");
            System.out.print("> ");
            Scanner scanner = new Scanner(System.in);
            String line;
            
            Stack<HashMap<String, Object>> scopes = null;
            
            
            while ((line = scanner.nextLine())!=null) {
                line = line + (char)13 + "\n";
                GPLLexer  lexer  = new GPLLexer();
                if (scopes==null) {
                    scopes = lexer.getScopes();
                } else {
                    lexer.setScopes(scopes);
                }
                
                GPLParser liner = new GPLParser(lexer);
                long start = System.currentTimeMillis();
                lexer.addInput(new StringReader("\n"+replace(line)));
                lexer.nextToken();
                liner.setInteractive(true);
                liner.parse();
                
                if (liner.getReturn()!=null && liner.getReturn().val!=null) {
                    System.out.println(((Type)(liner.getReturn().val)).getValue());
                }
                System.out.println("Successfully executed in " + ((System.currentTimeMillis() - start)/1000.0) + " seconds");
                
                System.out.print("> ");
            }
            scanner.close();

      } else {
          String file = args[0];
          Preprocessor p = new Preprocessor(file, "notused.tmp");
          GPLLexer  lexer  = new GPLLexer();
          lexer.nextToken();
          GPLParser parser = new GPLParser(lexer);
          parser.setPreprocessor(p);
          parser.parse();
      }
    }

    private static String replace(String s) {
        s = s.replace("==", "~");
        s = s.replace("!=", "`");
        s = s.replace(">=", "@");
		s = s.replace("<=", "$");
		s = s.replace("&&", "&");
		s = s.replace("||", "|");
        return s;
    }
    
    public static void error(String msg) {
      System.out.println("ERROR: " + msg);
      System.exit(1);
    }
  }
%}

%package parser
%semantic SemanticWrapper
%token PRINT INCLUDE DEF IF ELSE ELSIF WHILE NEXT LAST END EXIT RETURN ENDPOINT
%token NL
%token TYPE ID STRING_LITERAL NUMBER
%token '+' '-' '*' '/' '(' ')' '[' ']' '^' ',' '.' '!' '|' '&' '~' '`' '@' '$'
%right EQ NE GE LE LT GT
%left  '+' '-'
%left  '*' '/' '%' 
%right '^'
%right '!'
%left  '|'
%left  '&'

%% 

start 	: start NL block
        | block
		;

block   : action
        | defun
        | /* empty */
        ;

defun 	: DEF ID '(' defargswrapper ')' NL actions NL END
		;

actions : action
        | actions NL action
        ;
        
action 	: IF '(' expr ')' NL actions NL elsec END
		| WHILE '(' expr ')' NL actions NL END
		| INCLUDE '(' expr ')'          {include(((Type)$3.val).getValue()); setReturn(null);}
		| PRINT '(' expr ')'            {System.out.println(((Type)$3.val).getValue()); setReturn(null); }
		| NEXT
		| LAST
		| RETURN '(' expr ')'
		| RETURN
		| EXIT							{System.exit(0); setReturn(null); }
		| declaration
		| assignment
		| expr
		;
        
elsec	: ELSE action NL
		| ELSIF '(' expr ')' NL action NL elsec
		| /* empty */
		;
        
defargs : TYPE ID ',' defargs
		| TYPE ID
		;
defargswrapper 	: defargs
				| /* empty */
				;
args 	: expr ',' args                     {((ArrayList<Object>)$$.val).add(0,$1.val);}
		| expr                              {$$ = new SemanticWrapper(new ArrayList<Object>()); ((ArrayList<Object>)($$.val)).add($1.val);}
		;
argswrapper 	: args                      {$$ = $1;}
				| /* empty */               {$$ = new SemanticWrapper(null);}
				;
declaration : TYPE ID '=' expr              {declare(((StringType)($1.val)).getValue(),((StringType)($2.val)).getValue(),$4.val);}
            | TYPE ID '=' '[' listofexpr ']'    {declareList(((StringType)($1.val)).getValue(),((StringType)($2.val)).getValue(),$5.val); setReturn(new SemanticWrapper(lookup(((StringType)($2.val)).getValue())));}
			| TYPE ID                       {declare(((StringType)($1.val)).getValue(),((StringType)($2.val)).getValue(),null);}
			;
assignment	: ID '=' expr                   {modify(((StringType)($1.val)).getValue(), $3.val); setReturn($3); }
			| ID '=' '[' listofexpr ']'		    {declareList(((StringType)($1.val)).getValue(),((StringType)($2.val)).getValue(),$5.val); }
			;                                   /* TODO: FIX ABOVE */
listofexpr: expr ',' listofexpr				{((ArrayList<Object>)$$.val).add(0,$1.val);}
			| expr					{$$ = new SemanticWrapper(new ArrayList<Object>()); ((ArrayList<Object>)($$.val)).add($1.val);}
			;
/* get rid of the char strings */
expr		: ID '.' ID '(' argswrapper ')' {$$ = new SemanticWrapper(invoke(((StringType)($1.val)).getValue(), ((StringType)($3.val)).getValue(), ( $5.val==null ? null : (ArrayList<Object>)($5.val) ))); setReturn($$);}
			| ID '(' argswrapper ')'        {$$ = new SemanticWrapper(invoke(((StringType)($1.val)).getValue(), ( $3.val==null ? null : (ArrayList<Object>)($3.val) ))); setReturn($$);}
			| valexpr                       {$$.val = $1.val;}
			;
/* TODO: unary negation operator */
valexpr 	: valexpr '+' valexpr            {$$ = new SemanticWrapper(NumberType.add((NumberType)($1.val),(NumberType)($3.val))); setReturn($$); }
			| valexpr '-' valexpr            {$$ = new SemanticWrapper(NumberType.subtract((NumberType)($1.val),(NumberType)($3.val))); setReturn($$); }
			| valexpr '*' valexpr            {$$ = new SemanticWrapper(NumberType.multiply((NumberType)($1.val),(NumberType)($3.val))); setReturn($$); }
			| valexpr '/' valexpr            {$$ = new SemanticWrapper(NumberType.divide((NumberType)($1.val),(NumberType)($3.val))); setReturn($$); }
			| valexpr '^' valexpr            {$$ = new SemanticWrapper(NumberType.pow((NumberType)($1.val),(NumberType)($3.val))); setReturn($$); }
            | valexpr '%' valexpr            {$$ = new SemanticWrapper(NumberType.modulo((NumberType)($1.val),(NumberType)($3.val))); setReturn($$); }
            | valexpr '|' valexpr            {$$ = (GPLHelper.isTrue(((NumberType)($1.val)).getDouble()) ? TRUE_WRAPPER : (GPLHelper.isTrue(((NumberType)($3.val)).getDouble()) ? TRUE_WRAPPER : FALSE_WRAPPER)); setReturn($$); }
            | valexpr '&' valexpr            {$$ = ( GPLHelper.isTrue(((NumberType)($1.val)).getDouble()) ? 
                                                                        (GPLHelper.isTrue(((NumberType)($3.val)).getDouble()) ? TRUE_WRAPPER : FALSE_WRAPPER) : 
                                                                        FALSE_WRAPPER); 
                                             setReturn($$); }
			| valexpr EQ valexpr             {$$ = (compare($1, $3)==0 ? TRUE_WRAPPER : FALSE_WRAPPER); setReturn($$); }
            | valexpr NE valexpr             {$$ = (compare($1, $3)==0 ? FALSE_WRAPPER : TRUE_WRAPPER); setReturn($$); }
            | valexpr GT valexpr             {$$ = (compare($1, $3)>0 ? TRUE_WRAPPER : FALSE_WRAPPER); setReturn($$); }
            | valexpr LT valexpr             {$$ = (compare($1, $3)<0 ? TRUE_WRAPPER : FALSE_WRAPPER); setReturn($$); }
            | valexpr GE valexpr             {$$ = (compare($1, $3)>=0 ? TRUE_WRAPPER : FALSE_WRAPPER); setReturn($$); }
            | valexpr LE valexpr             {$$ = (compare($1, $3)<=0 ? TRUE_WRAPPER : FALSE_WRAPPER); setReturn($$); }
            | '(' valexpr ')'                {$$ = new SemanticWrapper($2.val); setReturn($$); }
			| symbol				         {$$ = new SemanticWrapper($1.val); setReturn($$); }
			;
symbol		: ID                    {$$ = new SemanticWrapper(lookup(((StringType)($1.val)).getValue())); setReturn($$); }
			| NUMBER 				{$$ = $1; setReturn($$); setReturn($$);}
			| STRING_LITERAL        {$$ = $1; setReturn($1); setReturn($$);}
			;

%%
  private GPLLexer lexer;
  
  private HashMap<String, Object> symbolTable = new HashMap<String, Object>();
  private Stack<HashMap<String, Object>> scopes;
  private boolean interactive;
  private SemanticWrapper returnVal = null;
  private static final SemanticWrapper TRUE_WRAPPER = new SemanticWrapper(new NumberType(1.0));
  private static final SemanticWrapper FALSE_WRAPPER = new SemanticWrapper(new NumberType(0.0));
  private Preprocessor p;
  
  public GPLParser(GPLLexer lexer) { 
    this.lexer = lexer; 
    scopes = lexer.getScopes();
    interactive = false;
  }
  
  //This activates the interpreted modes!
  public void setInteractive(boolean interactive) {
    this.interactive = interactive;
  }
  
  public void setScopes(Stack<HashMap<String, Object>> scopes) {
    this.scopes = scopes;
  }
  
  private void yyerror(String msg) {
    Main.error(yyerrno<0 ? msg : yyerrmsgs[yyerrno]);
  }
  
  private Object lookup(String name) {
    int index = scopes.size()-1;
    
    while (index>=0 && scopes.get(index).get(name)==null) {
        index--;
    }
    
    if (index>=0) {
        return scopes.get(index).get(name);
    } else {
        //TODO: throw an error, nothing was found
        return null;
    }
  }
  
  private void modify(String name, Object val) {
  
    int index = scopes.size()-1;
    
    boolean declared = false;
    while (index>=0) {
        if (scopes.get(index).get(name)!=null) {
            declared = true;
            break;
        }
        index--;
    }
    
    if (declared) {
        scopes.get(index).put(name, val);
    } else {
        System.out.println("Undeclared variable name: " + name);
        System.exit(1);
    }
    
  }
  
  private void include(String fileName) {}
  
  /**
  * This invokes a user defined function
  */
  private Object invoke(String name, ArrayList<Object> args) {
  
    if (args==null) args = new ArrayList<Object>();
  
    //All functions are global-scoped, meaning they're at the bottom of the stack
    Function f = null;
    try {
        f = (Function)scopes.get(0).get(name);
    } catch (Exception e) {
        System.out.println("Cannot find function: " + name + " - did you define it?");
        System.exit(1);
    }
    
    if (f==null) {
        System.out.println("Cannot find function: " + name + " - did you define it?");
        System.exit(1);
    }
    
    if (f.args.size()==1 && f.args.get(0).toString().length()==0) f.args = new ArrayList<String>();
    
    if (f.args.size()!=args.size()) {
        System.out.println("Function " + name + " expected " + f.args.size() + " arguments, not " + args.size());
        System.exit(1);
    }
    
    lexer.evalFunction(f.code, f.args, args);
    
    return lexer.lastReturn;
  }
  
  /**
  * This invokes a built-in function in GPL
  */
  private Object invoke(String name, String method, ArrayList<Object> args) {
  
    MethodHelper helper = new MethodHelper();
  
    Object obj = lookup(name);
    String typeName = obj.getClass().toString();
    
    
    Object[] actualArgs = null;
    
    if (args!=null) {
        actualArgs = args.toArray();
    }
    
    Object toReturn = null;
    
    
    try {
        if (actualArgs!=null) {
            Class[] types = helper.map.get(typeName).get(method).getParameterTypes();
            if (types.length!=actualArgs.length) {
                System.out.println("Wrong number of parameters for method: " + method);
                System.exit(1);
            }
            for (int i = 0; i < actualArgs.length; i++) {
                actualArgs[i] = types[i].cast(actualArgs[i]);
            }
            toReturn = helper.map.get(typeName).get(method).invoke(obj, actualArgs);
        } else {
            toReturn = helper.map.get(typeName).get(method).invoke(obj, new Object[0]);
        }
    } catch (Exception e) {
        System.out.println(e);
        System.out.println("Unknown method name: " + method);
    }
    return toReturn;
  }
  
  private void declare(String type, String name, Object val) {
    if (type.equals("Number")) {
        scopes.peek().put(name, (val==null ? new NumberType() : (NumberType)val));
    } else if (type.equals("Graph")) {
        scopes.peek().put(name, (val==null ? new MyGraph() : (MyGraph)val));
    } else if (type.equals("String")) {
        scopes.peek().put(name, (val==null ? new StringType() : (StringType)val));
    }
  }
  
  private void declareList(String type, String name, Object val){
    if(type.equals("Graph")){
       scopes.peek().put(name, (val==null ? new MyGraph() : new MyGraph((List<Type>)val)));
    }else{
        System.out.print("Type " + type + " does not support instantiation with a list!");
        System.exit(1);
    }
    
  }
  
  private void setReturn(SemanticWrapper toReturn) {
    if (interactive) {
        returnVal = toReturn;
    }
    
    scopes.peek();
  }
  
  public void setPreprocessor(Preprocessor p) {
    
    this.p = p;
    lexer.loadFunctions(p);
    
  }
  
  private int compare(SemanticWrapper a, SemanticWrapper b) {
    if (a.val==null && b.val==null) {
        return 0;
    } else if (a.val==null || b.val ==null) {
        //Non-null value is larger than null
        return (a.val==null ? -1 : 1);
    }
    
    if (a.val.getClass().toString().indexOf("NumberType")>0 || b.val.getClass().toString().indexOf("NumberType")>0) {
        //System.out.println("Comparing number!");
        return ((Double)(((NumberType)(a.val)).getDouble())).compareTo(((NumberType)(b.val)).getDouble());
    } else {
        //System.out.println("Comparing other!");
        return ((Type)(a.val)).getValue().compareTo(((Type)(b.val)).getValue());
    }
    
  }
  
  public SemanticWrapper getReturn() {
    return returnVal;
  }
  
  